"【心得】如何打印一棵红黑树"

"[md]\n## 红黑树实现\n### 以下是基于算法导论的思想的红黑树实现，当初为了方便调试，类内有一个打印红黑树的程序，因为版内有同学要求，所以放出来，大家可以改为普通二叉树的版本，大神们轻拍～\n\n### 程序运行结果\n![图片链接](https://bbs.byr.cn/att/ACM_ICPC/0/96459/296)\n\n### 程序代码\n```C++\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <tuple>\nusing namespace std;\n\nstatic int x = []()\n{\n    std::ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    return 0;\n}();\n\ntemplate <class T>\nvoid print_vec(vector<T> vec)\n{\n    for(int i = 0; i < vec.size(); i++)\n        cout << vec[i] << \" \";\n    cout << endl;\n}\n\nclass RBT\n{\npublic:\n    enum color {R, B};\n    \n    RBT()\n    {\n        color_ = B;\n    }\n\n    RBT(int key, RBT * left = RBT::nil, RBT * right = RBT::nil)\n    {\n        key_ = key;\n        left_ = left;\n        right_ = right;\n        left->parent_ = this;\n        right->parent_ = this;\n    }\n\n    RBT(int key, color c, RBT * left = RBT::nil, RBT * right = RBT::nil)\n    {\n        new(this)RBT(key, left, right);\n        color_ = c;\n    }\n\n    void level_print(RBT * T)\n    {\n        if(T == RBT::nil)\n            return;\n        queue<RBT * > q;\n        RBT * t = T;\n        q.push(t);\n        q.push(RBT::nil);\n        while(q.empty() == false)\n        {\n            t = q.front();\n            q.pop();\n            if(t == RBT::nil)\n            {\n                if(q.empty() == false)\n                    q.push(RBT::nil);\n                cout << endl;\n            }\n            else\n            {\n                cout << t->key_ << ' ';\n                if(t->left_ != RBT::nil)\n                    q.push(t->left_);\n                if(t->right_ != RBT::nil)\n                    q.push(t->right_);\n            }\n        }\n    }\n\n    vector<RBT * > get_inorder_tree_walk_vec(RBT * T)\n    {\n        vector<RBT * > vec;\n        stack<RBT * > s;\n        RBT * P = T;\n        while(P != RBT::nil || s.empty() == false)\n        {\n            while(P != RBT::nil)\n            {\n                s.push(P);\n                P = P->left_;\n            }\n            if(s.empty() == false)\n            {\n                P = s.top();\n                vec.push_back(P);\n                s.pop();\n                P = P->right_;\n            }\n        }\n        return vec;\n    }\n    \n    unordered_map<RBT * , int> generate_x_ind_map(RBT * T)\n    {\n        vector<RBT * > inorder_vec = get_inorder_tree_walk_vec(T);\n        unordered_map<RBT *, int> ind_map;\n        int tmp_ind = 0;\n        for(int i = 0; i < inorder_vec.size(); i++)\n        {\n            ind_map[inorder_vec[i]] = tmp_ind;\n            tmp_ind += to_string(inorder_vec[i]->key_).size() + 3;\n        }\n        return ind_map;\n    }\n\n    void put(char c, int times)\n    {\n        for(int i = 0; i < times; i++)\n            cout << c;\n    }\n\n    void draw_tree_without_lines(RBT * T)\n    {\n        if(T == RBT::nil)\n            return;\n        unordered_map<RBT *, int> ind_map = generate_x_ind_map(T);\n        queue<RBT * > q;\n        RBT * t = T;\n        q.push(t);\n        q.push(RBT::nil);\n        int tmp_line_ind = 0;\n        int tmp_vec_ind = 0;\n        while(q.empty() == false)\n        {\n            t = q.front();\n            q.pop();\n            if(t == RBT::nil)\n            {\n                if(q.empty() == false)\n                {\n                    q.push(RBT::nil);\n                    tmp_line_ind = 0;\n                    cout << endl;\n                }\n            }\n            else\n            {\n                put(' ', ind_map[t] - tmp_line_ind);\n                cout << '(' << t->key_ << ')';\n                tmp_line_ind += ind_map[t] - tmp_line_ind + 2 + \n                                to_string(t->key_).size();\n                tmp_vec_ind ++;\n                if(t->left_ != RBT::nil)\n                    q.push(t->left_);\n                if(t->right_ != RBT::nil)\n                    q.push(t->right_);\n            }\n        }\n    }\n\n    vector<vector<RBT * > > generate_print_base(RBT * T)\n    {\n        vector<vector<RBT * > > base_vec;\n        if(T == RBT::nil)\n            return base_vec;\n        queue<RBT * > q;\n        RBT * t = T;\n        q.push(t);\n        q.push(RBT::nil);\n        base_vec.push_back(vector<RBT * >());\n        while(q.empty() == false)\n        {\n            t = q.front();\n            q.pop();\n            if(t == RBT::nil)\n            {\n                if(q.empty() == false)\n                {\n                    q.push(RBT::nil);\n                    base_vec.push_back(vector<RBT * >());\n                }\n            }\n            else\n            {\n                if(t->left_ != RBT::nil)\n                    q.push(t->left_);\n                if(t->right_ != RBT::nil)\n                    q.push(t->right_);\n                base_vec[base_vec.size() - 1].push_back(t);\n            }\n        }\n        return base_vec;\n    }\n    \n    void draw_tree(RBT * T)\n    {\n        cout << \"draw_tree, (R), [B] : \" << endl;\n        unordered_map<RBT * , int> ind_map = generate_x_ind_map(T);\n        vector<vector<RBT * > > base_vec = generate_print_base(T);\n        for(int i = 0; i < base_vec.size(); i++)\n        {\n            int tmp_line_ind = 0;\n            int next_level_node_ind = 0;\n            vector<pair<int, char> > lr_sign_vec;\n            for(int j = 0; j < base_vec[i].size(); j++)\n            {\n                int tmp_node_ind = ind_map[base_vec[i][j]];\n                if(base_vec[i][j]->left_ != RBT::nil)\n                {\n                    int omament_ind = ind_map[base_vec[i + 1][next_level_node_ind ++]] + 1;\n                    int space_length = omament_ind - tmp_line_ind;\n                    put(' ', space_length);\n                    tmp_line_ind += space_length;\n                    lr_sign_vec.push_back(make_pair(tmp_line_ind - 1, '/'));\n                    int omament_length = tmp_node_ind - omament_ind;\n                    put('_', omament_length);\n                    tmp_line_ind += omament_length;\n                }\n                else\n                {\n                    int space_length = tmp_node_ind - tmp_line_ind;\n                    put(' ', space_length);\n                    tmp_line_ind += space_length;\n                }\n                if(base_vec[i][j]->color_ == R)\n                    cout << \"\\033[31m\" << \"(\" << base_vec[i][j]->key_ << \")\" << \"\\033[37m\";\n                else if(base_vec[i][j]->color_ == B)\n                    cout << \"\\033[1m\\033[30m\" << \"[\" << base_vec[i][j]->key_ << \"]\" << \"\\033[37m\";\n                //cout << base_vec[i][j]->parent_->key_;\n                tmp_line_ind += 2 + to_string(base_vec[i][j]->key_).size();\n                if(base_vec[i][j]->right_ != RBT::nil)\n                {\n                    int omament_ind = ind_map[base_vec[i + 1][next_level_node_ind]];\n                    int omament_length = omament_ind - tmp_line_ind + \n                        to_string(base_vec[i + 1][next_level_node_ind ++]->key_).size() + 2 - 1;\n                    put('_', omament_length);\n                    tmp_line_ind += omament_length;\n                    lr_sign_vec.push_back(make_pair(tmp_line_ind, '\\\\'));\n                }\n            }\n            cout << endl;\n            int tmp_lr_sign_line_ind = 0;\n            for(int k = 0; k < lr_sign_vec.size(); k++)\n            {\n                int tmp_lr_sign_line_space_length = lr_sign_vec[k].first - tmp_lr_sign_line_ind;\n                put(' ', tmp_lr_sign_line_space_length);\n                cout << lr_sign_vec[k].second;\n                tmp_lr_sign_line_ind += (tmp_lr_sign_line_space_length + 1);\n            }\n            cout << endl;\n        }\n    }\n\n    void left_rotate(RBT * T, RBT * x)\n    {\n        RBT * y = x->right_;\n        x->right_ = y->left_;\n        if(x->right_ != RBT::nil)\n            x->right_->parent_ = x;\n        y->parent_ = x->parent_;\n        if(x->parent_ == RBT::nil)\n            T->root_ = y;\n        else if(x == x->parent_->left_)\n            x->parent_->left_ = y;\n        else\n            x->parent_->right_ = y;\n        y->left_ = x;\n        x->parent_ = y;\n    }\n\n    void right_rotate(RBT * T, RBT * x)\n    {\n        RBT * y = x->left_;\n        x->left_ = y->right_;\n        if(x->left_ != RBT::nil)\n            x->left_->parent_ = x;\n        y->parent_ = x->parent_;\n        if(x->parent_ == RBT::nil)\n            T->root_ = y;\n        else if(x == x->parent_->left_)\n            x->parent_->left_ = y;\n        else\n            x->parent_->right_ = y;\n        y->right_ = x;\n        x->parent_ = y;\n    }\n\n    void rb_insert(RBT * T, RBT * z)\n    {\n        RBT * y = RBT::nil;\n        RBT * x = T->root_;\n        while(x != RBT::nil)\n        {\n            y = x;\n            if(z->key_ < x->key_)\n                x = x->left_;\n            else\n                x = x->right_;\n        }\n        z->parent_ = y;\n        if(y == RBT::nil)\n            T->root_ = z;\n        else if(z->key_ < y->key_)\n            y->left_ = z;\n        else\n            y->right_ = z;\n        z->left_ = RBT::nil;\n        z->right_ = RBT::nil;\n        z->color_ = R;\n        //cout << \"---Before fixup---\" << endl;\n        //draw_tree(T->root_);\n        rb_insert_fixup(T, z);\n    }\n\n    void rb_insert_fixup(RBT * T, RBT * z)\n    {\n        while(z->parent_->color_ == R)\n        {\n            if(z->parent_ == z->parent_->parent_->left_)\n            {\n                RBT * y = z->parent_->parent_->right_;\n                if(y->color_ == R)\n                {\n                    z->parent_->color_ = B;\n                    y->color_ = B;\n                    z->parent_->parent_->color_ = R;\n                    z = z->parent_->parent_;\n                    //cout << \"case 1\" << endl;\n                    //draw_tree(T->root_);\n                }\n                else\n                {\n                    if(z == z->parent_->right_)\n                    {\n                        z = z->parent_;\n                        left_rotate(T, z);\n                        //cout << \"case 2\" << endl;\n                        //draw_tree(T->root_);\n                    }\n                    z->parent_->color_ = B;\n                    z->parent_->parent_->color_ = R;\n                    right_rotate(T, z->parent_->parent_);\n                    //cout << \"case 3\" << endl;\n                    //draw_tree(T->root_);\n                }\n            }\n            else\n            {\n                RBT * y = z->parent_->parent_->left_;\n                if(y->color_ == R)\n                {\n                    z->parent_->color_ = B;\n                    y->color_ = B;\n                    z->parent_->parent_->color_ = R;\n                    z = z->parent_->parent_;\n                }\n                else\n                {\n                    if(z == z->parent_->left_)\n                    {\n                        z = z->parent_;\n                        right_rotate(T, z);\n                    }\n                    z->parent_->color_ = B;\n                    z->parent_->parent_->color_ = R;\n                    left_rotate(T, z->parent_->parent_);\n                }\n            }\n        }\n        T->root_->color_ = B;\n    }\n\n    void rb_transplant(RBT * T, RBT * u, RBT * v)\n    {\n        if(u->parent_ == RBT::nil)\n            T->root_ = v;\n        else if(u == u->parent_->left_)\n            u->parent_->left_ = v;\n        else\n            u->parent_->right_ = v;\n        v->parent_ = u->parent_;\n    }\n\n    RBT * tree_minimum(RBT * T)\n    {\n        while(T != RBT::nil && T->left_ != RBT::nil)\n            T = T->left_;\n        return T;\n    }\n\n    void rb_delete(RBT * T, RBT * z)\n    {\n        RBT * x;\n        RBT * y = z;\n        RBT::color y_ori_color = y->color_;\n        if(z->left_ == RBT::nil)\n        {\n            x = z->right_;\n            rb_transplant(T, z, z->right_);\n        }\n        else if(z->right_ == RBT::nil)\n        {\n            x = z->left_;\n            rb_transplant(T, z, z->left_);\n        }\n        else\n        {\n            y = tree_minimum(z->right_);\n            y_ori_color = y->color_;\n            x = y->right_;\n            if(y->parent_ == z)\n                x->parent_ = y;\n            else\n            {\n                rb_transplant(T, y, y->right_);\n                y->right_ = z->right_;\n                y->right_->parent_ = y;\n            }\n            rb_transplant(T, z, y);\n            y->left_ = z->left_;\n            y->left_->parent_ = y;\n            y->color_ = z->color_;\n        }\n        delete z;\n        z = nullptr;\n        if(y_ori_color == B)\n            rb_delete_fixup(T, x);\n    }\n\n    void rb_delete_fixup(RBT * T, RBT * x)\n    {\n        while(x != T->root_ && x->color_ == B)\n        {\n            if(x == x->parent_->left_)\n            {\n                RBT * w = x->parent_->right_;\n                if(w->color_ == R)\n                {\n                    w->color_ = B;\n                    x->parent_->color_ = R;\n                    left_rotate(T, x->parent_);\n                    w = x->parent_->right_;\n                }\n                if(w->left_->color_ == B && w->right_->color_ == B)\n                {\n                    w->color_ = R;\n                    x = x->parent_;\n                }\n                else\n                {\n                    if(w->right_->color_ == B)\n                    {\n                        w->left_->color_ = B;\n                        w->color_ = R;\n                        right_rotate(T, w);\n                        w = x->parent_->right_;\n                    }\n                    w->color_ = x->parent_->color_;\n                    x->parent_->color_ = B;\n                    w->right_->color_ = B;\n                    left_rotate(T, x->parent_);\n                    x = T->root_;\n                }\n            }\n            else\n            {\n                RBT * w = x->parent_->left_;\n                if(w->color_ == R)\n                {\n                    w->color_ = B;\n                    x->parent_->color_ = R;\n                    right_rotate(T, x->parent_);\n                    w = x->parent_->left_;\n                }\n                if(w->right_->color_ == B && w->left_->color_ == B)\n                {\n                    w->color_ = R;\n                    x = x->parent_;\n                }\n                else\n                {\n                    if(w->left_->color_ == B)\n                    {\n                        w->right_->color_ = B;\n                        w->color_ = R;\n                        left_rotate(T, w);\n                        w = x->parent_->left_;\n                    }\n                    w->color_ = x->parent_->color_;\n                    x->parent_->color_ = B;\n                    w->right_->color_ = B;\n                    right_rotate(T, x->parent_);\n                    x = T->root_;\n                }\n            }\n        }\n        x->color_ = B;\n    }\n\n    int key_;\n    RBT * left_ = RBT::nil;\n    RBT * right_ = RBT::nil;\n    RBT * parent_ = RBT::nil;\n    color color_;\n    static RBT * nil;\n    static RBT * root_;\n};\n\nRBT * RBT::nil = new RBT();\nRBT * RBT::root_ = nullptr;\n\nint main()\n{\n    RBT * T = new RBT(11, RBT::B,\n                      new RBT(2, RBT::R,\n                                new RBT(1, RBT::B),\n                              new RBT(7, RBT::B,\n                                      new RBT(5, RBT::R),\n                                      new RBT(8, RBT::R)\n                                     )\n                               ),\n                      new RBT(14, RBT::B,\n                                RBT::nil,\n                              new RBT(15, RBT::R)\n                               )\n                     );\n    T->root_ = T;\n    /*\n    T->draw_tree(T);\n    T->left_rotate(T, T->left_);\n    T->draw_tree(T);\n    T->right_rotate(T, T->left_);\n    T->draw_tree(T);\n    */\n    T->rb_insert(T, new RBT(4));\n    T->draw_tree(T->root_);\n    T->rb_delete(T->root_, T->root_->right_);\n    T->draw_tree(T->root_);\n    return 0;\n}\n```\n[/md]\n--\n"